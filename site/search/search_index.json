{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Latest Posts","text":"Apple Self-hosted GitHub Runner"},{"location":"about/","title":"None","text":"<p>This is a site to store the ongoing processes and workflows that I learn throughout the day. This may be useful for others working in a similar field, or at least entertaining with a twist of usefulness for everyone else.</p>"},{"location":"about/#whoami","title":"<code>&gt;&gt; whoami</code>","text":"<p>Dr Brady Planden is a Postdoctoral Research Associate at the University of Oxford. He received his Ph.D. from Oxford Brookes University with a thesis entitled \"Improvements on physics-informed models for lithium batteries\", which focused on reduced order electrochemical modelling techniques. Brady completed his Bachelor of Engineering at the University of Victoria. Brady is currently doing the following,</p> <ul> <li>Developing software for electrochemical modelling (PyBOP, LiiBRA, Galv)</li> <li>Conducting research on new lithium-ion battery chemistries with the EU's IntelLiGent Consortium</li> <li>Works as a post-doc in the Battery Intelligence Lab. This includes mentoring, random research IT, and a small amount of lecturing, etc.</li> </ul>"},{"location":"about/#ls","title":"<code>&gt;&gt; ls</code>","text":"<p>Here's a few resources that I have found useful (in no particular order):</p>  Writing   Dev   Research   Random  <ul> <li> DeepL Write  </li> <li> WizardLM  </li> <li> Claude AI  </li> <li> MacTex  </li> <li> Codecov  </li> <li> Pull Requests  </li> <li> Oxford RSE  </li> <li> tailscale  </li> <li> kitty terminal  </li> <li> iTerm2  </li> <li> OhMyZSH  </li> <li> Oh Shit, Git!?! </li> <li> Juliaup  </li> <li> pyenv  </li> <li> Advanced Python Mastery  </li> <li> Academic template  </li> <li> Simo S\u00e4rkk\u00e4  </li> <li> ungoogled chrome  </li> <li>  solaar  </li> <li> Remmina  </li> <li> Timeshift  </li> <li> backintime  </li> <li> bitwarden  </li> <li> fzf  </li>"},{"location":"about/#git-blame","title":"<code>&gt;&gt; git blame</code>","text":"<p>This site is built with Material for MkDocs, and was inspired from \"Why, Scott, Why?!\".</p>"},{"location":"blog/2023/github-runner/","title":"Apple Self-hosted GitHub Runner","text":"<p>In this post, I take a look at the process of creating a self-hosted ARM-based GitHub runner for CI/CD. This runner is currently being used for the development of PyBaMM and PyBOP.</p> <p></p> <p>TL;DR: Configure a self-hosted Apple M2 GitHub runner to validate the deployment of your repositories on Apple-based ARM hardware. An example workflow is presented from PyBaMM's daily testing workflow. This example is over 2X faster than the GitHub-hosted hardware.</p>"},{"location":"blog/2023/github-runner/#what-is-a-runner","title":"What is a runner?","text":"<p>As per GitHub's definition:</p> <p>A self-hosted runner is a system that you deploy and manage to execute jobs from GitHub Actions</p> <p>So we are responsible for the \"system\" that will execute the GitHub actions. Seems reasonable, but why bother with this overhead when GitHub will manage the whole workflow for you? </p> <p>This is the crux of the TIL: to achieve both robust and high performance testing workflows, a self-hosted runner is a great solution (assuming you have the hardware lying around). </p> <p>As this article was being written, GitHub [https://github.blog/2023-10-02-introducing-the-new-apple-silicon-powered-m1-macos-larger-runner-for-github-actions/){:target='_blank'} released their Apple M1 runner. Previously, M-Series ARM support wasn't offered, so a self-hosted runner was needed to validate and develop on this hardware. Other potential use cases include the need to deploy private or proprietary software, or the need for a system environment that GitHub doesn't offer. This is also covered on GitHub,</p> <p>Self-hosted runners offer more control of hardware, operating system, and software tools than GitHub-hosted runners provide. With self-hosted runners, you can create custom hardware configurations that meet your needs with processing power or memory to run larger jobs, install software available on your local network, and choose an operating system not offered by GitHub-hosted runners. Self-hosted runners can be physical, virtual, in a container, on-premises, or in a cloud.</p>"},{"location":"blog/2023/github-runner/#lets-get-to-it","title":"Let's get to it","text":"<p>The setup begins with the creation of a runner-specific macOS account, such as <code>runner</code>, with limited privileges. This is the first step in hardening the runner against malicious code that might be deployed on it. To do this, run the following bash command on an account with administrative privileges.</p> <pre><code>account create runner\n</code></pre> <p>Next, log in to this newly created account and run the GitHub repository-specific commands to associate the runner with the selected repository. These can be found in the repository settings under <code>Settings -&gt; Actions -&gt; Runners</code>. This will look like:</p> <p></p> <p>The installation and validation commands then look like,</p> <p><pre><code># Create a folder\n$ mkdir actions-runner &amp;&amp; cd actions-runner\n# Download the latest runner package\n$ curl -o actions-runner-osx-arm64-2.308.0.tar.gz -L https://github.com/actions/runner/releases/download/v2.308.0/actions-runner-osx-arm64-2.308.0.tar.gz\n# Optional: Validate the hash\n$ echo \"a8b2c25868e4296cbd203342754223dd2cc17f91585592c99ccd85b587d05310  actions-runner-osx-arm64-2.308.0.tar.gz\" | shasum -a 256 -c\n# Extract the installer\n$ tar xzf ./actions-runner-osx-arm64-2.308.0.tar.gz\n</code></pre> with the repository-specific configuration as,</p> <pre><code># Create the runner and start the configuration experience\n$ ./config.sh --url https://github.com/xxx/xxx --token xxxxxx\n# Last step, run it!\n$ ./run.sh\n</code></pre> <p>Running the above code will set up the runner configuration and links it to the repository of your choice. The runner should then appear in the GitHub repository as,</p> <p></p> <p>This is mostly it, the remaining setup involves adding the runner to your CI/CD workflows. This is fairly straightforward and requires the target workflow to use the tags associated with this runner. In this case, using <code>self-hosted</code>, <code>macOS</code> or <code>ARM64</code> will deploy the workflow on the self-hosted runner.</p>"},{"location":"blog/2023/github-runner/#example-workflow","title":"Example workflow","text":"<p>For an example of how to integrate your workflow onto the runner, the following is an excerpt from the PyBaMM scheduled test workflow.</p> <pre><code>#M-series Mac Mini\n  build-apple-mseries:\n    needs: style\n    runs-on: [self-hosted, macOS, ARM64]\n    env:\n      GITHUB_PATH: ${PYENV_ROOT/bin:$PATH}\n    strategy:\n      fail-fast: false\n      matrix:\n        python-version: [\"3.8\", \"3.9\", \"3.10\", \"3.11\"]\n\n    steps:\n      - uses: actions/checkout@v4\n      - name: Install python &amp; create virtualenv\n        shell: bash\n        run: |\n          eval \"$(pyenv init -)\"\n          pyenv install ${{ matrix.python-version }} -s\n          pyenv virtualenv ${{ matrix.python-version }} pybamm-${{ matrix.python-version }}\n\n      - name: Install dependencies &amp; run unit tests for Windows and MacOS\n        shell: bash\n        run: |\n          eval \"$(pyenv init -)\"\n          pyenv activate pybamm-${{ matrix.python-version }}\n          python -m pip install --upgrade pip wheel setuptools nox\n          python -m nox -s unit\n\n      - name: Run integration tests for Windows and MacOS\n        run: |\n          eval \"$(pyenv init -)\"\n          pyenv activate pybamm-${{ matrix.python-version }}\n          python -m nox -s integration\n\n      - name: Uninstall pyenv-virtualenv &amp; python\n        if: always()\n        shell: bash\n        run: |\n          eval \"$(pyenv init -)\"\n          pyenv activate pybamm-${{ matrix.python-version }}\n          pyenv uninstall -f $( python --version )\n</code></pre> <p>The above workflow produces the following:</p> <ul> <li>Sets the job to deploy on the self-hosted runner</li> <li>Installs Python and creates a virtual environment using pyenv</li> <li>Installs the required Python dependencies for PyBaMM and the test suite</li> <li>Runs the standard unit and integration tests using Nox</li> <li>Tears down the test environment (regardless of the test results)</li> </ul> <p>The results of this workflow are shown in the figure below. At the time of writing, the GitHub runner finishes in about 20 minutes, while the self-hosted runner finishes in 8 minutes.</p> <p></p>"}]}